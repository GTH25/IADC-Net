#IADC-Net
import torch
import torch.nn as nn
from math import pi
from torchsummary import summary
import torch.nn.functional as F
from thop import profile

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

def Laplace(p): #Laplace小波基函数
    A = 0.08
    ep = 0.03
    tal = 0.1
    f = 50
    w = 2 * pi * f
    q = torch.tensor(1 - pow(ep, 2))
    y = A * torch.exp((-ep / (torch.sqrt(q))) * (w * (p - tal))) * (-torch.sin(w * (p - tal)))
    return y


class Laplace_fast(nn.Module):

    def __init__(self, out_channels, kernel_size, in_channels=1):

        super(Laplace_fast, self).__init__()

        if in_channels != 1:

            msg = "MexhConv only support one input channel (here, in_channels = {%i})" % (in_channels)
            raise ValueError(msg)

        self.out_channels = out_channels
        self.kernel_size = kernel_size - 1

        if kernel_size % 2 == 0:
            self.kernel_size = self.kernel_size + 1

        self.a_ = nn.Parameter((torch.linspace(1, 10, out_channels)).view(-1, 1), requires_grad=True) #尺度参数

        self.b_ = nn.Parameter((torch.linspace(0, 10, out_channels)).view(-1, 1), requires_grad=True) #平移参数


    def forward(self, waveforms):

        time_disc = torch.linspace(0, 1, steps=int((self.kernel_size)))
        # print('a_:', self.a_)
        # print('b_:', self.b_)

        p1 = (time_disc.to(device) - self.b_.to(device)) / self.a_.to(device)

        laplace_filter = Laplace(p1)

        self.filters = (laplace_filter).view(self.out_channels, 1, self.kernel_size).to(device)
        # print('Laplace:', self.filters[0], self.filters[15])


        return F.conv1d(waveforms, self.filters, stride=1, padding=1, dilation=1, bias=None, groups=1) #Laplace小波卷积

# --------------------------------------------------------


def Mexh(p): #Mexhat小波基函数
    # p = 0.04 * p  # 将时间转化为在[-5,5]这个区间内
    y = (1 - torch.pow(p, 2)) * torch.exp(-torch.pow(p, 2) / 2)

    return y

class Mexh_fast(nn.Module):

    def __init__(self, out_channels, kernel_size, in_channels=1):

        super(Mexh_fast, self).__init__()

        if in_channels != 1:

            msg = "MexhConv only support one input channel (here, in_channels = {%i})" % (in_channels)
            raise ValueError(msg)

        self.out_channels = out_channels

        self.kernel_size = kernel_size - 1

        if kernel_size % 2 == 0:
            self.kernel_size = self.kernel_size + 1


        self.a_ = nn.Parameter((torch.linspace(1, 10, out_channels)).view(-1, 1), requires_grad=True) #尺度参数

        self.b_ = nn.Parameter((torch.linspace(0, 10, out_channels)).view(-1, 1), requires_grad=True) #平移参数

    def forward(self, waveforms):

        time_disc_right = torch.linspace(0, (self.kernel_size / 2) - 1,
                                         steps=int((self.kernel_size / 2)))

        time_disc_left = torch.linspace(-(self.kernel_size / 2) + 1, -1,
                                        steps=int((self.kernel_size / 2)))

        p1 = time_disc_right.to(device) - self.b_.to(device) / self.a_.to(device)

        p2 = time_disc_left.to(device) - self.b_.to(device) / self.a_.to(device)

        Mexh_right = Mexh(p1)
        Mexh_left = Mexh(p2)

        Mexh_filter = torch.cat([Mexh_left, Mexh_right], dim=1)  # 40x1x250

        self.filters = (Mexh_filter).view(self.out_channels, 1, self.kernel_size).to(device)
        # print('Mexh:', self.filters[0], self.filters[15])

        return F.conv1d(waveforms, self.filters, stride=1, padding=1, dilation=1, bias=None, groups=1) #Mexhat小波卷积

# --------------------------------------------------------



def Morlet(p): #Morlet小波基函数
    C = pow(pi, 0.25)
    # p = 0.03 * p
    y = C * torch.exp(-torch.pow(p, 2) / 2) * torch.cos(2 * pi * p)
    return y

class Morlet_fast(nn.Module):

    def __init__(self, out_channels, kernel_size, in_channels=1):

        super(Morlet_fast, self).__init__()

        if in_channels != 1:

            msg = "MexhConv only support one input channel (here, in_channels = {%i})" % (in_channels)
            raise ValueError(msg)

        self.out_channels = out_channels
        self.kernel_size = kernel_size - 1

        if kernel_size % 2 == 0:
            self.kernel_size = self.kernel_size + 1

        self.a_ = nn.Parameter((torch.linspace(1, 10, out_channels)).view(-1, 1), requires_grad=True) #尺度参数

        self.b_ = nn.Parameter((torch.linspace(0, 10, out_channels)).view(-1, 1), requires_grad=True) #平移参数

    def forward(self, waveforms):

        time_disc_right = torch.linspace(0, (self.kernel_size / 2) - 1,
                                         steps=int((self.kernel_size / 2)))

        time_disc_left = torch.linspace(-(self.kernel_size / 2) + 1, -1,
                                        steps=int((self.kernel_size / 2)))

        p1 = time_disc_right.to(device) - self.b_.to(device) / self.a_.to(device)
        p2 = time_disc_left.to(device) - self.b_.to(device)/ self.a_.to(device)
        #print('p2:', p2)

        Morlet_right = Morlet(p1)
        Morlet_left = Morlet(p2)

        Morlet_filter = torch.cat([Morlet_left, Morlet_right], dim=1)  # 40x1x250

        self.filters = (Morlet_filter).view(self.out_channels, 1, self.kernel_size).to(device)
        # print('Morlet:', self.filters[0], self.filters[15])

        return F.conv1d(waveforms, self.filters, stride=1, padding=1, dilation=1, bias=None, groups=1) #Morlet小波卷积

# --------------------------------------------------------



def piecewise_linear(x, a, b): #根据阈值a和可学习参数去噪函数

    row_indices = torch.randint(0, 16, (a.size(0),))
    b = b[row_indices]

    # 当x大于a-b时
    y = torch.where(x >= (a-b).unsqueeze(-1),  x + (b - a).unsqueeze(-1), torch.tensor(0.))
    # 当-a-b<=x<=a-b时
    y = torch.where((x > (-a-b).unsqueeze(-1)) & (x < (a-b).unsqueeze(-1)), 0, y)
    # 当x小于-a-b时
    y = torch.where(x <= (-a-b).unsqueeze(-1), x + (b + a).unsqueeze(-1), y)

    return y


class YUZHI(nn.Module): #计算阈值函数

    def __init__(self, input_channels, hidden_size):

        super(YUZHI, self).__init__()

        self.fc1 = nn.Linear(in_features=input_channels, out_features=hidden_size)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(in_features=hidden_size, out_features=input_channels)

    def forward(self, x):
        y = torch.mean(torch.abs(x), dim=2) 
        x = self.fc1(y)
        x = self.relu(x)
        x = torch.nn.functional.normalize(x, p=2, dim=0)
        x = self.fc2(x)
        x = torch.sigmoid(x)
        x = x * y

        return x #输出自适应阈值

class SoftThreshold(nn.Module): #软阈值去噪函数
    def __init__(self):
        super(SoftThreshold, self).__init__()
        #self.B_ = nn.Parameter((torch.randn(64))*0.3, requires_grad=True)
        self.B_ = nn.Parameter((torch.full([16, 16], 1.0)), requires_grad=True) #可学习参数微调阈值

    def forward(self, x):
        # print('xin:', x.shape)
        # torch.save(x, 'ROBOT_beforedenoising.pt')
        Threshold = YUZHI(16, 32) #设置阈值参数
        A_ = Threshold(x) #计算阈值
        #print('A_:', A_.shape)
        #self.B_  = nn.Parameter((torch.full(A_.size(), 0.2)), requires_grad=True)
        x = piecewise_linear(x, A_, self.B_.to(device)) #去噪
        # torch.save(x, 'ROBOT_afterdenoising.pt')
        return x #自适应阈值去噪后输出特征
# --------------------------------------------------------


class EnergyEntropyWeightedLayer(nn.Module):
    """能量与熵比加权层"""
    def __init__(self):

        super(EnergyEntropyWeightedLayer, self).__init__()
    
    def forward(self, x):

        energy = torch.sum(x ** 2, dim=2)  # 计算能量
        # torch.save(energy, 'energy.pt')
        hii = x ** 2
        max_values, max_indices = torch.max(hii, dim=2)
        pii = hii /max_values.unsqueeze(-1)
        pii[pii == 0] = 1 #避免log0为无穷无法计算
        entropy = -torch.sum(pii * torch.log2(pii), dim=2)  # 计算熵

        weighted_term = energy / entropy #计算能量与熵比


        weights_normalized = torch.sigmoid(weighted_term) #权重归一化

        row_mins, _ = weights_normalized.min(dim=1, keepdim=True)
        row_maxs, _ = weights_normalized.max(dim=1, keepdim=True)
        weights_normalized = (weights_normalized - row_mins) / (row_maxs - row_mins + 1e-8)  # +1e-8 避免除零

        x = x + x * weights_normalized.unsqueeze(-1) #加权后通道特征

        return x

class ConcatenateLayer(nn.Module): #通道拼接及加权函数

    def __init__(self, dim=1):

        super(ConcatenateLayer, self).__init__()

        self.dim = dim
        self.BN = nn.BatchNorm1d(48)

    def forward(self, x1, x2, x3):

        EW = EnergyEntropyWeightedLayer()

        x = torch.cat((x1, x2, x3), dim=self.dim) #三种小波系数通道拼接
        x = EW(x) #能量与熵比通道加权
        x = self.BN(x) #标准化

        return x

concat_layer = ConcatenateLayer(dim=1)
# --------------------------------------------------------



class IADC_Net(nn.Module):

    def __init__(self, in_channel=1, out_channel=10):

        super(FDWCN_Net, self).__init__()

        self.conv1_1 = nn.Sequential(
            Laplace_fast(16, 16),
            SoftThreshold(), #软阈值去噪
            nn.BatchNorm1d(16),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )

        self.conv1_2 = nn.Sequential(
            Mexh_fast(16, 16),
            SoftThreshold(),
            nn.BatchNorm1d(16),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )

        self.conv1_3 = nn.Sequential(
            Morlet_fast(16, 16),
            SoftThreshold(),
            nn.BatchNorm1d(16),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )

        self.conv2 = nn.Sequential(
            nn.Conv1d(48, 48, 16),
            nn.BatchNorm1d(48),
            nn.Tanh(),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )

        self.conv3 = nn.Sequential(
            nn.Conv1d(48, 16, 5),
            nn.BatchNorm1d(16),
            nn.Tanh(),
            nn.AdaptiveMaxPool1d(64)  # adaptive change the outputsize
        )

        self.fc1 = nn.Sequential(
            nn.Linear(16 * 64, 120),
            nn.Tanh(),
        )

        self.fc2 = nn.Sequential(
            nn.Linear(120, 84),
            nn.Tanh(),
        )

        self.fc3 = nn.Linear(84, out_channel)

    def forward(self, x):

        x_1 = self.conv1_1(x) #Laplace小波卷积
        x_2 = self.conv1_2(x) #Mexhat小波卷积
        x_3 = self.conv1_3(x) #Morlet小波卷积

        x = concat_layer(x_1, x_2, x_3) #三种小波系数融合

        x = self.conv2(x) #卷积层1
        x = self.conv3(x) #卷积层2

        x = x.view(x.size()[0], -1) #将上述特征拉伸为向量输入进全连接层实现分类

        x = self.fc1(x) #全连接层1
        x = self.fc2(x) #全连接层2
        logits = self.fc3(x)  #全连接层3

        probas = F.softmax(logits, dim=1)  # softmax分类器

        return logits, probas
