#IADC-Net
import torch
import torch.nn as nn
from math import pi
from torchsummary import summary
import torch.nn.functional as F
from thop import profile

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

def Laplace(p): 
#Laplace wavelet basis function
    A = 0.08
    ep = 0.03
    tal = 0.1
    f = 50
    w = 2 * pi * f
    q = torch.tensor(1 - pow(ep, 2))
    y = A * torch.exp((-ep / (torch.sqrt(q))) * (w * (p - tal))) * (-torch.sin(w * (p - tal)))
    return y


class Laplace_fast(nn.Module):
"""Laplace wavelet convolution"""

    def __init__(self, out_channels, kernel_size, in_channels=1):

        super(Laplace_fast, self).__init__()

        if in_channels != 1:

            msg = "MexhConv only support one input channel (here, in_channels = {%i})" % (in_channels)
            raise ValueError(msg)

        self.out_channels = out_channels
        self.kernel_size = kernel_size - 1

        if kernel_size % 2 == 0:
            self.kernel_size = self.kernel_size + 1

        self.a_ = nn.Parameter((torch.linspace(1, 10, out_channels)).view(-1, 1), requires_grad=True) #scale parameter

        self.b_ = nn.Parameter((torch.linspace(0, 10, out_channels)).view(-1, 1), requires_grad=True) #translation parameters


    def forward(self, waveforms):

        time_disc = torch.linspace(0, 1, steps=int((self.kernel_size)))

        p1 = (time_disc.to(device) - self.b_.to(device)) / self.a_.to(device)

        laplace_filter = Laplace(p1)

        self.filters = (laplace_filter).view(self.out_channels, 1, self.kernel_size).to(device)


        return F.conv1d(waveforms, self.filters, stride=1, padding=1, dilation=1, bias=None, groups=1) #Laplace wavelet convolution

# --------------------------------------------------------


def Mexh(p): 
#Mexhat wavelet basis function
    y = (1 - torch.pow(p, 2)) * torch.exp(-torch.pow(p, 2) / 2)

    return y

class Mexh_fast(nn.Module):
"""Mexhat wavelet convolution"""

    def __init__(self, out_channels, kernel_size, in_channels=1):

        super(Mexh_fast, self).__init__()

        if in_channels != 1:

            msg = "MexhConv only support one input channel (here, in_channels = {%i})" % (in_channels)
            raise ValueError(msg)

        self.out_channels = out_channels

        self.kernel_size = kernel_size - 1

        if kernel_size % 2 == 0:
            self.kernel_size = self.kernel_size + 1


        self.a_ = nn.Parameter((torch.linspace(1, 10, out_channels)).view(-1, 1), requires_grad=True) #scale parameter

        self.b_ = nn.Parameter((torch.linspace(0, 10, out_channels)).view(-1, 1), requires_grad=True) #translation parameters

    def forward(self, waveforms):

        time_disc_right = torch.linspace(0, (self.kernel_size / 2) - 1,
                                         steps=int((self.kernel_size / 2)))

        time_disc_left = torch.linspace(-(self.kernel_size / 2) + 1, -1,
                                        steps=int((self.kernel_size / 2)))

        p1 = time_disc_right.to(device) - self.b_.to(device) / self.a_.to(device)

        p2 = time_disc_left.to(device) - self.b_.to(device) / self.a_.to(device)

        Mexh_right = Mexh(p1)
        Mexh_left = Mexh(p2)

        Mexh_filter = torch.cat([Mexh_left, Mexh_right], dim=1)  # 40x1x250

        self.filters = (Mexh_filter).view(self.out_channels, 1, self.kernel_size).to(device)

        return F.conv1d(waveforms, self.filters, stride=1, padding=1, dilation=1, bias=None, groups=1) #Mexhat wavelet convolution

# --------------------------------------------------------



def Morlet(p): 
#Morlet wavelet basis function
    C = pow(pi, 0.25)
    # p = 0.03 * p
    y = C * torch.exp(-torch.pow(p, 2) / 2) * torch.cos(2 * pi * p)
    return y

class Morlet_fast(nn.Module):
"""Morlet wavelet convolution"""

    def __init__(self, out_channels, kernel_size, in_channels=1):

        super(Morlet_fast, self).__init__()

        if in_channels != 1:

            msg = "MexhConv only support one input channel (here, in_channels = {%i})" % (in_channels)
            raise ValueError(msg)

        self.out_channels = out_channels
        self.kernel_size = kernel_size - 1

        if kernel_size % 2 == 0:
            self.kernel_size = self.kernel_size + 1

        self.a_ = nn.Parameter((torch.linspace(1, 10, out_channels)).view(-1, 1), requires_grad=True) #scale parameter

        self.b_ = nn.Parameter((torch.linspace(0, 10, out_channels)).view(-1, 1), requires_grad=True) #translation parameters

    def forward(self, waveforms):

        time_disc_right = torch.linspace(0, (self.kernel_size / 2) - 1,
                                         steps=int((self.kernel_size / 2)))

        time_disc_left = torch.linspace(-(self.kernel_size / 2) + 1, -1,
                                        steps=int((self.kernel_size / 2)))

        p1 = time_disc_right.to(device) - self.b_.to(device) / self.a_.to(device)
        p2 = time_disc_left.to(device) - self.b_.to(device)/ self.a_.to(device)
        #print('p2:', p2)

        Morlet_right = Morlet(p1)
        Morlet_left = Morlet(p2)

        Morlet_filter = torch.cat([Morlet_left, Morlet_right], dim=1)  # 40x1x250

        self.filters = (Morlet_filter).view(self.out_channels, 1, self.kernel_size).to(device)

        return F.conv1d(waveforms, self.filters, stride=1, padding=1, dilation=1, bias=None, groups=1) #Morlet wavelet convolution

# --------------------------------------------------------



def piecewise_linear(x, a, b):
"""Denoising function based on threshold a and learnable parameters"""

    row_indices = torch.randint(0, 16, (a.size(0),))
    b = b[row_indices]

    # if x > a-b
    y = torch.where(x >= (a-b).unsqueeze(-1),  x + (b - a).unsqueeze(-1), torch.tensor(0.))
    # if -a-b <= x <= a-b
    y = torch.where((x > (-a-b).unsqueeze(-1)) & (x < (a-b).unsqueeze(-1)), 0, y)
    # if x < -a-b
    y = torch.where(x <= (-a-b).unsqueeze(-1), x + (b + a).unsqueeze(-1), y)

    return y


class YUZHI(nn.Module):
"""Threshold calculation function"""

    def __init__(self, input_channels, hidden_size):

        super(YUZHI, self).__init__()

        self.fc1 = nn.Linear(in_features=input_channels, out_features=hidden_size)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(in_features=hidden_size, out_features=input_channels)

    def forward(self, x):
        y = torch.mean(torch.abs(x), dim=2) 
        x = self.fc1(y)
        x = self.relu(x)
        x = torch.nn.functional.normalize(x, p=2, dim=0)
        x = self.fc2(x)
        x = torch.sigmoid(x)
        x = x * y

        return x #Output adaptive threshold

class SoftThreshold(nn.Module): 
"""Soft Thresholding Denoising Function"""

    def __init__(self):

        super(SoftThreshold, self).__init__()

        self.B_ = nn.Parameter((torch.full([16, 16], 1.0)), requires_grad=True) #The learnable parameters are used for fine-tuning the threshold

    def forward(self, x):
        Threshold = YUZHI(16, 32) #Call the threshold function
        A_ = Threshold(x) #Calculate the threshold
        x = piecewise_linear(x, A_, self.B_.to(device)) #Denoising

        return x #Output features after adaptive threshold denoising
# --------------------------------------------------------


class EnergyEntropyWeightedLayer(nn.Module):
    """Energy and Entropy Ratio Weighted Layer"""
    def __init__(self):

        super(EnergyEntropyWeightedLayer, self).__init__()
    
    def forward(self, x):

        energy = torch.sum(x ** 2, dim=2)  # Calculate energy
        hii = x ** 2
        pii = hii /energy.unsqueeze(-1)
        pii[pii == 0] = 1 #Avoid log0 being infinite and thus unable to be calculated.
        entropy = -torch.sum(pii * torch.log2(pii), dim=2)  # Calculate entropy

        weighted_term = energy / entropy #Calculate the ratio of energy to entropy


        weights_normalized = torch.sigmoid(weighted_term) #Weight normalization

        row_mins, _ = weights_normalized.min(dim=1, keepdim=True)
        row_maxs, _ = weights_normalized.max(dim=1, keepdim=True)
        weights_normalized = (weights_normalized - row_mins) / (row_maxs - row_mins + 1e-8)  # +1e-8 Avoid division by zero

        x = x + x * weights_normalized.unsqueeze(-1) #Weighted channel features

        return x

class ConcatenateLayer(nn.Module): #Channel stitching and weighting function

    def __init__(self, dim=1):

        super(ConcatenateLayer, self).__init__()

        self.dim = dim
        self.BN = nn.BatchNorm1d(48)

    def forward(self, x1, x2, x3):

        EW = EnergyEntropyWeightedLayer()

        x = torch.cat((x1, x2, x3), dim=self.dim) #Combining three wavelet coefficient channels
        x = EW(x) #Energy and entropy ratio channel weighting
        x = self.BN(x) #Standardization

        return x

concat_layer = ConcatenateLayer(dim=1)
# --------------------------------------------------------



class IADC_Net(nn.Module):
"""IADC_Net"""

    def __init__(self, in_channel=1, out_channel=10):

        super(IADC_Net, self).__init__()

        self.conv1_1 = nn.Sequential(
            Laplace_fast(16, 16),
            SoftThreshold(), #Soft threshold denoising
            nn.BatchNorm1d(16),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )

        self.conv1_2 = nn.Sequential(
            Mexh_fast(16, 16),
            SoftThreshold(),
            nn.BatchNorm1d(16),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )

        self.conv1_3 = nn.Sequential(
            Morlet_fast(16, 16),
            SoftThreshold(),
            nn.BatchNorm1d(16),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )

        self.conv2 = nn.Sequential(
            nn.Conv1d(48, 48, 16),
            nn.BatchNorm1d(48),
            nn.Tanh(),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )

        self.conv3 = nn.Sequential(
            nn.Conv1d(48, 16, 5),
            nn.BatchNorm1d(16),
            nn.Tanh(),
            nn.AdaptiveMaxPool1d(64)  # adaptive change the outputsize
        )

        self.fc1 = nn.Sequential(
            nn.Linear(16 * 64, 120),
            nn.Tanh(),
        )

        self.fc2 = nn.Sequential(
            nn.Linear(120, 84),
            nn.Tanh(),
        )

        self.fc3 = nn.Linear(84, out_channel)

    def forward(self, x):

        x_1 = self.conv1_1(x) #Laplace Wavelet Convolution
        x_2 = self.conv1_2(x) #Mexhat Wavelet Convolution
        x_3 = self.conv1_3(x) #Morlet Wavelet Convolution

        x = concat_layer(x_1, x_2, x_3) #Fusion of three types of wavelet coefficients

        x = self.conv2(x) #Convolutional Layer 1
        x = self.conv3(x) #Convolutional Layer 2

        x = x.view(x.size()[0], -1) #Expand these features into vectors and input them into the fully connected layer to achieve classification.

        x = self.fc1(x) #Fully connected layer 1
        x = self.fc2(x) #Fully connected layer 2
        logits = self.fc3(x)  #Fully connected layer 3

        probas = F.softmax(logits, dim=1)  # Softmax classifier

        return logits, probas
