#IADC-Net
def Laplace(p):
    A = 0.08
    ep = 0.03
    tal = 0.1
    f = 50
    w = 2 * pi * f
    q = torch.tensor(1 - pow(ep, 2))
    y = A * torch.exp((-ep / (torch.sqrt(q))) * (w * (p - tal))) * (-torch.sin(w * (p - tal)))
    return y


class Laplace_fast(nn.Module):

    def __init__(self, out_channels, kernel_size, in_channels=1):

        super(Laplace_fast, self).__init__()

        if in_channels != 1:

            msg = "MexhConv only support one input channel (here, in_channels = {%i})" % (in_channels)
            raise ValueError(msg)

        self.out_channels = out_channels
        self.kernel_size = kernel_size - 1

        if kernel_size % 2 == 0:
            self.kernel_size = self.kernel_size + 1

        self.a_ = nn.Parameter((torch.linspace(1, 10, out_channels)).view(-1, 1), requires_grad=True)

        self.b_ = nn.Parameter((torch.linspace(0, 10, out_channels)).view(-1, 1), requires_grad=True)


    def forward(self, waveforms):

        time_disc = torch.linspace(0, 1, steps=int((self.kernel_size)))
        # print('a_:', self.a_)
        # print('b_:', self.b_)

        p1 = (time_disc.to(device) - self.b_.to(device)) / self.a_.to(device)

        laplace_filter = Laplace(p1)

        self.filters = (laplace_filter).view(self.out_channels, 1, self.kernel_size).to(device)
        # print('Laplace:', self.filters[0], self.filters[15])


        return F.conv1d(waveforms, self.filters, stride=1, padding=1, dilation=1, bias=None, groups=1)

# --------------------------------------------------------


def Mexh(p):
    # p = 0.04 * p  # 将时间转化为在[-5,5]这个区间内
    y = (1 - torch.pow(p, 2)) * torch.exp(-torch.pow(p, 2) / 2)

    return y

class Mexh_fast(nn.Module):

    def __init__(self, out_channels, kernel_size, in_channels=1):

        super(Mexh_fast, self).__init__()

        if in_channels != 1:

            msg = "MexhConv only support one input channel (here, in_channels = {%i})" % (in_channels)
            raise ValueError(msg)

        self.out_channels = out_channels

        self.kernel_size = kernel_size - 1

        if kernel_size % 2 == 0:
            self.kernel_size = self.kernel_size + 1


        self.a_ = nn.Parameter((torch.linspace(1, 10, out_channels)).view(-1, 1), requires_grad=True)

        self.b_ = nn.Parameter((torch.linspace(0, 10, out_channels)).view(-1, 1), requires_grad=True)

    def forward(self, waveforms):

        time_disc_right = torch.linspace(0, (self.kernel_size / 2) - 1,
                                         steps=int((self.kernel_size / 2)))

        time_disc_left = torch.linspace(-(self.kernel_size / 2) + 1, -1,
                                        steps=int((self.kernel_size / 2)))

        p1 = time_disc_right.to(device) - self.b_.to(device) / self.a_.to(device)

        p2 = time_disc_left.to(device) - self.b_.to(device) / self.a_.to(device)

        Mexh_right = Mexh(p1)
        Mexh_left = Mexh(p2)

        Mexh_filter = torch.cat([Mexh_left, Mexh_right], dim=1)  # 40x1x250

        self.filters = (Mexh_filter).view(self.out_channels, 1, self.kernel_size).to(device)
        # print('Mexh:', self.filters[0], self.filters[15])

        return F.conv1d(waveforms, self.filters, stride=1, padding=1, dilation=1, bias=None, groups=1)

# --------------------------------------------------------



def Morlet(p):
    C = pow(pi, 0.25)
    # p = 0.03 * p
    y = C * torch.exp(-torch.pow(p, 2) / 2) * torch.cos(2 * pi * p)
    return y

class Morlet_fast(nn.Module):

    def __init__(self, out_channels, kernel_size, in_channels=1):

        super(Morlet_fast, self).__init__()

        if in_channels != 1:

            msg = "MexhConv only support one input channel (here, in_channels = {%i})" % (in_channels)
            raise ValueError(msg)

        self.out_channels = out_channels
        self.kernel_size = kernel_size - 1

        if kernel_size % 2 == 0:
            self.kernel_size = self.kernel_size + 1

        self.a_ = nn.Parameter((torch.linspace(1, 10, out_channels)).view(-1, 1), requires_grad=True)

        self.b_ = nn.Parameter((torch.linspace(0, 10, out_channels)).view(-1, 1), requires_grad=True)

    def forward(self, waveforms):

        time_disc_right = torch.linspace(0, (self.kernel_size / 2) - 1,
                                         steps=int((self.kernel_size / 2)))

        time_disc_left = torch.linspace(-(self.kernel_size / 2) + 1, -1,
                                        steps=int((self.kernel_size / 2)))

        p1 = time_disc_right.to(device) - self.b_.to(device) / self.a_.to(device)
        p2 = time_disc_left.to(device) - self.b_.to(device)/ self.a_.to(device)
        #print('p2:', p2)

        Morlet_right = Morlet(p1)
        Morlet_left = Morlet(p2)

        Morlet_filter = torch.cat([Morlet_left, Morlet_right], dim=1)  # 40x1x250

        self.filters = (Morlet_filter).view(self.out_channels, 1, self.kernel_size).to(device)
        # print('Morlet:', self.filters[0], self.filters[15])

        return F.conv1d(waveforms, self.filters, stride=1, padding=1, dilation=1, bias=None, groups=1)

# ----------------------------------------------



def piecewise_linear(x, a, b):
    # 当x大于a-b时
    row_indices = torch.randint(0, 16, (a.size(0),))
    b = b[row_indices]
    y = torch.where(x >= (a-b).unsqueeze(-1),  x + (b - a).unsqueeze(-1), torch.tensor(0.))
    # 当-a-b<=x<=a-b时
    y = torch.where((x > (-a-b).unsqueeze(-1)) & (x < (a-b).unsqueeze(-1)), 0, y)
    # 当x小于-a-b时
    y = torch.where(x <= (-a-b).unsqueeze(-1), x + (b + a).unsqueeze(-1), y)
    return y

class YUZHI(nn.Module):
    def __init__(self, input_channels, hidden_size):
        super(YUZHI, self).__init__()
        self.fc1 = nn.Linear(in_features=input_channels, out_features=hidden_size)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(in_features=hidden_size, out_features=input_channels)

    def forward(self, x):
        y = torch.mean(torch.abs(x), dim=2)# Average over channels and squeeze to remove singleton dimension
        x = self.fc1(y)
        x = self.relu(x)
        x = torch.nn.functional.normalize(x, p=2, dim=0)
        x = self.fc2(x)
        x = torch.sigmoid(x)
        x = x * y
        return x

class SoftThreshold(nn.Module):
    def __init__(self):
        super(SoftThreshold, self).__init__()
        self.B_ = nn.Parameter((torch.full([16, 16], 1.0)), requires_grad=True)

    def forward(self, x):
        Threshold = YUZHI(16, 32)
        A_ = Threshold(x)
        x = piecewise_linear(x, A_, self.B_.to(device))
        return x
# ----------------------------------------------



class EnergyEntropyWeightedLayer(nn.Module):
    """能量与熵比加权层"""
    def __init__(self):
        super(EnergyEntropyWeightedLayer, self).__init__()
    
    def forward(self, x):
        energy = torch.sum(x ** 2, dim=2)  # 计算能量
        hii = x ** 2
        max_values, max_indices = torch.max(hii, dim=2)
        pii = hii / max_values.unsqueeze(-1)
        pii[pii == 0] = 1
        entropy = -torch.sum(pii * torch.log2(pii), dim=2)  # 计算熵
        weighted_term = energy / entropy
        weights_normalized = torch.sigmoid(weighted_term)

        row_mins, _ = weights_normalized.min(dim=1, keepdim=True)
        row_maxs, _ = weights_normalized.max(dim=1, keepdim=True)
        weights_normalized = (weights_normalized - row_mins) / (row_maxs - row_mins + 1e-8)  # +1e-8 避免除零
        torch.save(weights_normalized, 'weights_normalized-ROBOT.pt')
        x = x + x * weights_normalized.unsqueeze(-1)
        return x

class ConcatenateLayer(nn.Module):
    def __init__(self, dim=1):
        super(ConcatenateLayer, self).__init__()
        self.dim = dim
        self.BN = nn.BatchNorm1d(48)

    def forward(self, x1, x2, x3):
        x = torch.cat((x1, x2, x3), dim=self.dim)
        x = EW(x)
        x = self.BN(x)
        return x
concat_layer = ConcatenateLayer(dim=1)

# --------------------------------------------------------

class FDWCN_Net(nn.Module):
    def __init__(self, in_channel=1, out_channel=10):
        super(FDWCN_Net, self).__init__()
        self.conv1_1 = nn.Sequential(
            Laplace_fast(16, 16),
            SoftThreshold(),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )
        self.conv1_2 = nn.Sequential(
            Mexh_fast(16, 16),
            SoftThreshold(),
            nn.BatchNorm1d(16),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )
        self.conv1_3 = nn.Sequential(
            Morlet_fast(16, 16),
            SoftThreshold(),
            nn.BatchNorm1d(16),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )
        self.conv2 = nn.Sequential(
            nn.Conv1d(48, 48, 16),
            nn.BatchNorm1d(48),
            nn.Tanh(),
            nn.MaxPool1d(kernel_size=2, stride=2),
        )
        self.conv3 = nn.Sequential(
            nn.Conv1d(48, 16, 5),
            nn.BatchNorm1d(16),
            nn.Tanh(),
            nn.AdaptiveMaxPool1d(64)，
        )
        self.fc1 = nn.Sequential(
            nn.Linear(16 * 64, 120),
            nn.Tanh(),
        )
        self.fc2 = nn.Sequential(
            nn.Linear(120, 84),
            nn.Tanh(),
        )
        self.fc3 = nn.Linear(84, out_channel)

    def forward(self, x):
        x_1 = self.conv1_1(x)
        x_2 = self.conv1_2(x)
        x_3 = self.conv1_3(x)
        x = concat_layer(x_1, x_2, x_3)
        x = self.conv2(x)
        x = self.conv3(x)
        x = x.view(x.size()[0], -1)
        x = self.fc1(x)
        x = self.fc2(x)
        logits = self.fc3(x)
        probas = F.softmax(logits, dim=1)
        return logits, probas
